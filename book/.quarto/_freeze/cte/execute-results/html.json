{
  "hash": "7d0907287ed3bb1f14e94dd7013b5be2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: CTE (Common Table Expression) improves code readability and reduces repetition\nformat:\n  html:\n    toc: true\nexecute:\n  eval: false\n  output: true\njupyter: python3\n---\n\n\n## Why to use a CTE\n\nA CTE is a named select statement that can be reused in a single query.\n\nComplex SQL queries often involve multiple sub-queries. Multiple sub-queries make the code hard to read.Use a Common Table Expression (CTE) to make your queries readable\n\nCTEs also make testing complex queries simpler\n\n## How to define a CTE \n\nUse the `WITH` key word to start defining a CTE, the with key word is not necessary for consequetive CTE definitions.\n\n::: {#a23ada10 .cell execution_count=1}\n``` {.python .cell-code}\n%%sql\nuse prod.db\n```\n:::\n\n\n::: {#98321fc8 .cell execution_count=2}\n``` {.python .cell-code}\n%%sql\n-- CTE definition\nWITH\n  supplier_nation_metrics AS ( -- CTE 1 defined using WITH keyword\n    SELECT\n      n.n_nationkey,\n      SUM(l.l_QUANTITY) AS num_supplied_parts\n    FROM\n      lineitem l\n      JOIN supplier s ON l.l_suppkey = s.s_suppkey\n      JOIN nation n ON s.s_nationkey = n.n_nationkey\n    GROUP BY\n      n.n_nationkey\n  ),\n  buyer_nation_metrics AS ( -- CTE 2 defined just as a name\n    SELECT\n      n.n_nationkey,\n      SUM(l.l_QUANTITY) AS num_purchased_parts\n    FROM\n      lineitem l\n      JOIN orders o ON l.l_orderkey = o.o_orderkey\n      JOIN customer c ON o.o_custkey = c.c_custkey\n      JOIN nation n ON c.c_nationkey = n.n_nationkey\n    GROUP BY\n      n.n_nationkey\n  )\nSELECT -- The final select will not have a comma before it\n  n.n_name AS nation_name,\n  s.num_supplied_parts,\n  b.num_purchased_parts\nFROM\n  nation n\n  LEFT JOIN supplier_nation_metrics s ON n.n_nationkey = s.n_nationkey\n  LEFT JOIN buyer_nation_metrics b ON n.n_nationkey = b.n_nationkey\nLIMIT 10;\n```\n:::\n\n\nNote that the last CTE does not have a `,` after it. \n\nLet's look another example: Calculate the money lost due to discounts. Use lineitem to get the price of items (without discounts) that are part of an order and compare it to the order.\n\nadd: details extn\n\nHint: Figure out the grain that the comparison need to be made in. Think in steps i.e. get the price of all the items in an order without discounts and then compare it to the orders data whose totalprice has been computed with discounts.\n\n::: {#d0fc0a2b .cell execution_count=3}\n``` {.python .cell-code}\n%%sql\nWITH lineitem_agg AS (\n    SELECT \n        l_orderkey,\n        SUM(l_extendedprice) AS total_price_without_discount\n    FROM \n        lineitem\n    GROUP BY \n        l_orderkey\n)\nSELECT \n    o.o_orderkey,\n    o.o_totalprice, \n    l.total_price_without_discount - o.o_totalprice AS amount_lost_to_discount\nFROM \n    orders o\nJOIN \n    lineitem_agg l ON o.o_orderkey = l.l_orderkey\nORDER BY \n    o.o_orderkey;\n```\n:::\n\n\nHere are the schemas of orders and lineitem tables.\nadd: TPCH image\n\n## Recreating similar CTE is a sign that it should be a table\n\nA sql query with multiple temporary tables is better than a 1000-line SQL query with numerous CTEs.\n\nKeep the number of CTE per query small (depends on the size of the query, but typically < 5)\n\nCasestudy:\n\nRead the query below and answer the question\n\n```sql\nwith orders as (\nselect\n        order_id,\n        customer_id,\n        order_status,\n        order_purchase_timestamp::TIMESTAMP AS order_purchase_timestamp,\n        order_approved_at::TIMESTAMP AS order_approved_at,\n        order_delivered_carrier_date::TIMESTAMP AS order_delivered_carrier_date,\n        order_delivered_customer_date::TIMESTAMP AS order_delivered_customer_date,\n        order_estimated_delivery_date::TIMESTAMP AS order_estimated_delivery_date\n    from raw_layer.orders\n    ),\n stg_customers as (\n    select\n        customer_id,\n        zipcode,\n        city,\n        state_code,\n        datetime_created::TIMESTAMP as datetime_created,\n        datetime_updated::TIMESTAMP as datetime_updated,\n        dbt_valid_from,\n        dbt_valid_to\n    from customer_snapshot\n),\nstate as (\nselect\n        state_id::INT as state_id,\n        state_code::VARCHAR(2) as state_code,\n        state_name::VARCHAR(30) as state_name\n    from raw_layer.state\n    ),\ndim_customers as (\nselect\n    c.customer_id,\n    c.zipcode,\n    c.city,\n    c.state_code,\n    s.state_name,\n    c.datetime_created,\n    c.datetime_updated,\n    c.dbt_valid_from::TIMESTAMP as valid_from,\n    case\n        when c.dbt_valid_to is NULL then '9999-12-31'::TIMESTAMP\n        else c.dbt_valid_to::TIMESTAMP\n    end as valid_to\nfrom stg_customers as c\ninner join state as s on c.state_code = s.state_code\n)\nselect\n    o.order_id,\n    o.customer_id,\n    o.order_status,\n    o.order_purchase_timestamp,\n    o.order_approved_at,\n    o.order_delivered_carrier_date,\n    o.order_delivered_customer_date,\n    o.order_estimated_delivery_date,\n    c.zipcode as customer_zipcode,\n    c.city as customer_city,\n    c.state_code as customer_state_code,\n    c.state_name as customer_state_name\nfrom orders as o\ninner join dim_customers as c on\n    o.customer_id = c.customer_id\n    and o.order_purchase_timestamp >= c.valid_from\n    and o.order_purchase_timestamp <= c.valid_to;\n```\n\n## Exercises\n\n1. Sellers who sell atleast one of the top 10 selling parts.\n\n## Recommended reading\n\n1. https://www.startdataengineering.com/post/using-common-table-expression-in-redshift/ \n\n",
    "supporting": [
      "cte_files"
    ],
    "filters": [],
    "includes": {}
  }
}