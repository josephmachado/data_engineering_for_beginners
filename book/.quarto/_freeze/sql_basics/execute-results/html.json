{
  "hash": "73f8a67a770da59671c8d2037527abc3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Read data, Combine tables, & aggregate numbers to understand business performance\nformat:\n  html:\n    toc: true\nexecute:\n  eval: false\n  output: true\njupyter: python3\n---\n\n\n## Setup\n\nTo run the code, you need to generate the data and load it into Spark tables. Use the script below to do this:\n\n::: {#dca83b71 .cell execution_count=1}\n``` {.python .cell-code}\n%%capture\n%%bash\npython ./generate_data.py\npython ./run_ddl.py\n```\n:::\n\n\n## A Spark catalog can have multiple schemas, & schemas can have multiple tables\n\nTypically, database servers can have multiple databases; each database can have multiple schemas. Each schema can have multiple tables, and each table can have multiple columns.\n\n**Note:** We use Trino, which has `catalogs` that allow it to connect with the different underlying systems. (e.g., Postgres, Redis, Hive, etc.)\n\nIn our lab, we use Trino, and we can check the available catalogs, their schemas, the tables in a schema, & the columns in a table, as shown below.\n\n::: {#397d4afb .cell execution_count=2}\n``` {.python .cell-code}\n%%sql \nshow catalogs;\n```\n:::\n\n\n::: {#0e7a498d .cell execution_count=3}\n``` {.python .cell-code}\n%%sql\nshow schemas IN demo;\n\n-- Catalog -> schema\n```\n:::\n\n\n::: {#e2987e29 .cell execution_count=4}\n``` {.python .cell-code}\n%%sql\nshow schemas IN prod;\n\n-- schema -> namespace\n```\n:::\n\n\n::: {#1eb753aa .cell execution_count=5}\n``` {.python .cell-code}\n%%sql\nshow tables IN prod.db -- namespace -> Table\n```\n:::\n\n\n::: {#e1c7189c .cell execution_count=6}\n``` {.python .cell-code}\n%%sql --show\nselect * from prod.db.customer limit 2\n```\n:::\n\n\nNote how, when referencing the table name, we use the full path, i.e., `schema.table_name`. We can skip using the full path of the table if we define which schema to use for the entirety of this session, as shown below.\n\n::: {#f0b697bb .cell execution_count=7}\n``` {.python .cell-code}\n%%sql --show\nuse prod.db\n```\n:::\n\n\n::: {#accd1e51 .cell execution_count=8}\n``` {.python .cell-code}\n%%sql\nDESCRIBE lineitem\n```\n:::\n\n\n::: {#87474f0b .cell execution_count=9}\n``` {.python .cell-code}\n%%sql\nDESCRIBE extended lineitem\n```\n:::\n\n\n## Use SELECT...FROM, LIMIT, WHERE, & ORDER BY to read the required data \n\nThe most common use for querying is to read data from our tables. We can do this using a `SELECT ... FROM` statement, as shown below.\n\n::: {#e30a8871 .cell execution_count=10}\n``` {.python .cell-code}\n%%sql\n-- use * to specify all columns\nSELECT\n  *\nFROM\n  orders\nLIMIT\n  4\n```\n:::\n\n\n::: {#96b9347a .cell execution_count=11}\n``` {.python .cell-code}\n%%sql\n-- use column names to only read data from those columns\nSELECT\n  o_orderkey,\n  o_totalprice\nFROM\n  orders\nLIMIT\n  4\n```\n:::\n\n\nHowever, running a `SELECT ... FROM` statement can cause issues when the data set is extensive. If you want to examine the data, use `LIMIT n` to instruct Trino to retrieve only the first n rows. \n\nWe can use the 'WHERE' clause to retrieve rows that match specific criteria. We can specify one or more filters within the' WHERE' clause. The `WHERE` clause with more than one filter can use combinations of `AND` and `OR` criteria to combine the filter criteria, as shown below.\n\n::: {#2b7b9f77 .cell execution_count=12}\n``` {.python .cell-code}\n%%sql\n-- all customer rows that have c_nationkey = 20\nSELECT\n  *\nFROM\n  customer\nWHERE\n  c_nationkey = 20\nLIMIT\n  10;\n```\n:::\n\n\n::: {#f90f9b51 .cell execution_count=13}\n``` {.python .cell-code}\n%%sql\n-- all customer rows that have c_nationkey = 20 and c_acctbal > 1000\nSELECT\n  *\nFROM\n  customer\nWHERE\n  c_nationkey = 20\n  AND c_acctbal > 1000\nLIMIT\n  10;\n```\n:::\n\n\n::: {#246974ca .cell execution_count=14}\n``` {.python .cell-code}\n%%sql\n-- all customer rows that have c_nationkey = 20 or c_acctbal > 1000\nSELECT\n  *\nFROM\n  customer\nWHERE\n  c_nationkey = 20\n  OR c_acctbal > 1000\nLIMIT\n  10;\n```\n:::\n\n\n::: {#77d42c79 .cell execution_count=15}\n``` {.python .cell-code}\n%%sql\n-- all customer rows that have (c_nationkey = 20 and c_acctbal > 1000) or rows that have c_nationkey = 11\nSELECT\n  *\nFROM\n  customer\nWHERE\n  (\n    c_nationkey = 20\n    AND c_acctbal > 1000\n  )\n  OR c_nationkey = 11\nLIMIT\n  10;\n```\n:::\n\n\nWe can combine multiple filter clauses, as seen above. We have seen examples of equals (`=`) and greater than (`>`) conditional operators. There are 6 **conditional operators**, they are\n\n1. `<` Less than\n2. `>` Greater than\n3. `<=` Less than or equal to\n4. `>=` Greater than or equal to\n5. `=` Equal\n6. `<>` and `!=` both represent Not equal (some DBs only support one of these)\n\nAdditionally, for string types, we can make **pattern matching with `like` condition**. In a `like` condition, a `_` means any single character, and `%` means zero or more characters, for example.\n\n::: {#d0db80e8 .cell execution_count=16}\n``` {.python .cell-code}\n%%sql\n-- all customer rows where the name has a 381 in it\nSELECT\n  *\nFROM\n  customer\nWHERE\n  c_name LIKE '%381%';\n```\n:::\n\n\n::: {#d9d8eb08 .cell execution_count=17}\n``` {.python .cell-code}\n%%sql\n-- all customer rows where the name ends with a 381\nSELECT\n  *\nFROM\n  customer\nWHERE\n  c_name LIKE '%381';\n```\n:::\n\n\n::: {#4f8d6c8a .cell execution_count=18}\n``` {.python .cell-code}\n%%sql\n-- all customer rows where the name starts with a 381\nSELECT\n  *\nFROM\n  customer\nWHERE\n  c_name LIKE '381%';\n```\n:::\n\n\n::: {#99f9e44a .cell execution_count=19}\n``` {.python .cell-code}\n%%sql\n-- all customer rows where the name has a combination of any character and 9 and 1\nSELECT\n  *\nFROM\n  customer\nWHERE\n  c_name LIKE '%_91%';\n```\n:::\n\n\nWe can also filter for more than one value using `IN` and `NOT IN`.\n\n::: {#776ebe3b .cell execution_count=20}\n``` {.python .cell-code}\n%%sql\n-- all customer rows which have nationkey = 10 or nationkey = 20\nSELECT\n  *\nFROM\n  customer\nWHERE\n  c_nationkey IN (10, 20);\n```\n:::\n\n\n::: {#50e5290c .cell execution_count=21}\n``` {.python .cell-code}\n%%sql\n-- all customer rows which have do not have nationkey as 10 or 20\nSELECT\n  *\nFROM\n  customer\nWHERE\n  c_nationkey NOT IN (10, 20);\n```\n:::\n\n\nWe can get the number of rows in a table using `count(*)` as shown below.\n\n::: {#cfc0d1a7 .cell execution_count=22}\n``` {.python .cell-code}\n%%sql\nSELECT\n  COUNT(*)\nFROM\n  customer;\n\n-- 1500\n```\n:::\n\n\n::: {#c12696ac .cell execution_count=23}\n``` {.python .cell-code}\n%%sql\nSELECT\n  COUNT(*)\nFROM\n  lineitem;\n\n-- 60175\n```\n:::\n\n\nIf we want to get the rows sorted by values in a specific column, we use `ORDER BY`, for example.\n\n::: {#2f53faa6 .cell execution_count=24}\n``` {.python .cell-code}\n%%sql\n-- Will show the first ten customer records with the lowest custkey\n-- rows are ordered in ASC order by default\nSELECT\n  *\nFROM\n  orders\nORDER BY\n  o_custkey\nLIMIT\n  10;\n```\n:::\n\n\n::: {#daadbdc0 .cell execution_count=25}\n``` {.python .cell-code}\n%%sql\n-- Will show the first ten customer's records with the highest custkey\nSELECT\n  *\nFROM\n  orders\nORDER BY\n  o_custkey DESC\nLIMIT\n  10;\n```\n:::\n\n\n## Combine data from multiple tables using JOINs\n\nWe can combine data from multiple tables using joins. When we write a join query, we have a format as shown below.\n\n```sql\nSELECT\n    a.*\nFROM\n    table_a a -- LEFT table a\n    JOIN table_b b -- RIGHT table b\n    ON a.id = b.id\n```\n\nThe table specified first (table_a) is the left table, whereas the table specified second is the right table. When we have multiple tables joined, we consider the joined dataset from the first two tables as the left table and the third table as the right table (The DB optimizes our join for performance).\n\n```sql\nSELECT\n    a.*\nFROM\n    table_a a -- LEFT table a\n    JOIN table_b b -- RIGHT table b\n    ON a.id = b.id\n    JOIN table_c c -- LEFT table is the joined data from table_a & table_b, right table is table_c\n    ON a.c_id = c.id\n```\n\nThere are five main types of joins:\n\n![Join Types](./images/join_types.png)\n\n### 1. Inner join (default): Get rows with the same join keys from both tables\n\n::: {#2964698b .cell execution_count=26}\n``` {.python .cell-code}\n%%sql\nSELECT\n  o.o_orderkey,\n  l.l_orderkey\nFROM\n  orders o\n  JOIN lineitem l ON o.o_orderkey = l.l_orderkey\n  AND o.o_orderdate BETWEEN l.l_shipdate - INTERVAL '5' DAY AND l.l_shipdate  + INTERVAL '5' DAY\nLIMIT\n  10;\n```\n:::\n\n\n::: {#e123e68e .cell execution_count=27}\n``` {.python .cell-code}\n%%sql\nSELECT\n  COUNT(o.o_orderkey) AS order_rows_count,\n  COUNT(l.l_orderkey) AS lineitem_rows_count\nFROM\n  orders o\n  JOIN lineitem l ON o.o_orderkey = l.l_orderkey\n  AND o.o_orderdate BETWEEN l.l_shipdate - INTERVAL '5' DAY AND l.l_shipdate  + INTERVAL '5' DAY;\n-- 2477, 2477\n```\n:::\n\n\n**Note:** `JOIN` defaults to INNER JOIN`.\n\nThe output will contain rows from orders and lineitem that match at least one row from the other table with the specified join condition (same orderkey and orderdate within a 5-day window of the ship date). \n\nWe can also see that 2,477 rows from the orders and lineitem tables matched.\n\n### 2. Left outer join (aka left join): Get all rows from the left table and only matching rows from the right table.\n\n::: {#5b4bbbd5 .cell execution_count=28}\n``` {.python .cell-code}\n%%sql\n\nSELECT\n  o.o_orderkey,\n  l.l_orderkey\nFROM\n  orders o\n  LEFT JOIN lineitem l ON o.o_orderkey = l.l_orderkey\n  AND o.o_orderdate BETWEEN l.l_shipdate - INTERVAL '5' DAY AND l.l_shipdate  + INTERVAL '5' DAY\nLIMIT\n  10;\n```\n:::\n\n\n::: {#5528b1b4 .cell execution_count=29}\n``` {.python .cell-code}\n%%sql\nSELECT\n  COUNT(o.o_orderkey) AS order_rows_count,\n  COUNT(l.l_orderkey) AS lineitem_rows_count\nFROM\n  orders o\n  LEFT JOIN lineitem l ON o.o_orderkey = l.l_orderkey\n  AND o.o_orderdate BETWEEN l.l_shipdate - INTERVAL '5' DAY AND l.l_shipdate  + INTERVAL '5' DAY;\n-- 15197, 2477\n```\n:::\n\n\nThe output will include all rows from orders and the rows from lineitem that were able to find at least one matching row from the orders table with the specified join condition (same orderkey and orderdate within a 5-day window of the ship date). \n\nWe can also see that the number of rows from the orders table is 15,197 & from the lineitem table is 2,477. The number of rows in orders is 15,000, but the join condition produces 15,197 since some orders match with multiple line items.\n\n### 3. Right outer join (aka right join): Get matching rows from the left and all rows from the right table.\n\n::: {#1717b710 .cell execution_count=30}\n``` {.python .cell-code}\n%%sql\nSELECT\n  o.o_orderkey,\n  l.l_orderkey\nFROM\n  orders o\n  RIGHT JOIN lineitem l ON o.o_orderkey = l.l_orderkey\n  AND o.o_orderdate BETWEEN l.l_shipdate - INTERVAL '5' DAY AND l.l_shipdate  + INTERVAL '5' DAY\nLIMIT\n  10;\n```\n:::\n\n\n::: {#d792c142 .cell execution_count=31}\n``` {.python .cell-code}\n%%sql\nSELECT\n  COUNT(o.o_orderkey) AS order_rows_count,\n  COUNT(l.l_orderkey) AS lineitem_rows_count\nFROM\n  orders o\n  RIGHT JOIN lineitem l ON o.o_orderkey = l.l_orderkey\n  AND o.o_orderdate BETWEEN l.l_shipdate - INTERVAL '5' DAY AND l.l_shipdate  + INTERVAL '5' DAY;\n-- 2477, 60175\n```\n:::\n\n\nThe output will include the rows from orders that match at least one row from the lineitem table with the specified join condition (same orderkey and orderdate within a 5-day window of the ship date) and all rows from the lineitem table.\n\nWe can also see that the number of rows from the orders table is 15,197 & from the lineitem table is 2,477.\n\n### 4. Full outer join: Get matched and unmatched rows from both tables.\n\n::: {#31eb9e07 .cell execution_count=32}\n``` {.python .cell-code}\n%%sql\nSELECT\n  o.o_orderkey,\n  l.l_orderkey\nFROM\n  orders o\n  FULL OUTER JOIN lineitem l ON o.o_orderkey = l.l_orderkey\n  AND o.o_orderdate BETWEEN l.l_shipdate - INTERVAL '5' DAY AND l.l_shipdate  + INTERVAL '5' DAY\nLIMIT\n  10\n```\n:::\n\n\n::: {#f4724877 .cell execution_count=33}\n``` {.python .cell-code}\n%%sql\nSELECT\n  COUNT(o.o_orderkey) AS order_rows_count,\n  COUNT(l.l_orderkey) AS lineitem_rows_count\nFROM\n  orders o\n  FULL OUTER JOIN lineitem l ON o.o_orderkey = l.l_orderkey\n  AND o.o_orderdate BETWEEN l.l_shipdate - INTERVAL '5' DAY AND l.l_shipdate  + INTERVAL '5' DAY;\n-- 15197, 60175\n```\n:::\n\n\nThe output will include all rows from orders that match at least one row from the lineitem table with the specified join condition (same orderkey and orderdate within a 5-day window of the ship date) and all rows from the lineitem table.\n\nWe can also see that the number of rows from the orders table is 15,197 & from the lineitem table is 2,477.\n\n### 5. Cross join: Join every row in the left table with every row in the right table\n\n::: {#a7d09a2b .cell execution_count=34}\n``` {.python .cell-code}\n%%sql\nSELECT\n  n.n_name AS nation_c_name,\n  r.r_name AS region_c_name\nFROM\n  nation n\n  CROSS JOIN region r;\n```\n:::\n\n\nThe output will have every row of the nation joined with every row of the region. There are 25 nations and five regions, leading to 125 rows in our result from the cross-join.\n\n\nThere are cases where we need to join a table with itself, known as a SELF-join. Let's consider an example.\n\n1. For every customer order, get the order placed earlier in the same week (Sunday - Saturday, not the previous seven days). Only show customer orders that have at least one such order.\n\n::: {#d1625bb3 .cell execution_count=35}\n``` {.python .cell-code}\n%%sql    \nSELECT\n    o1.o_custkey as o1_custkey,\n    o1.o_totalprice as o1_totalprice,\n    o1.o_orderdate as o1_orderdate,\n    o2.o_totalprice as o2_totalprice,\n    o2.o_orderdate as o2_orderdate\nFROM\n    orders o1\n    JOIN orders o2 ON o1.o_custkey = o2.o_custkey\n    AND year(o1.o_orderdate) = year(o2.o_orderdate)\n    AND weekofyear(o1.o_orderdate) = weekofyear(o2.o_orderdate)\nWHERE\n    o1.o_orderkey != o2.o_orderkey\nLIMIT\n    10;\n```\n:::\n\n\n## Combine data from multiple rows into one using GROUP BY\n\nMost analytical queries require calculating metrics that involve combining data from multiple rows. `GROUP BY` allows us to perform aggregate calculations on data from a set of rows recognized by values of specified column(s). For example:\n\n1. Create a report that shows the number of orders per orderpriority segment.\n\n::: {#220bc8d0 .cell execution_count=36}\n``` {.python .cell-code}\n%%sql\nSELECT\n  o_orderpriority,\n  COUNT(*) AS num_orders\nFROM\n  orders\nGROUP BY\n  o_orderpriority;\n```\n:::\n\n\nIn the above query, we group the data by `orderpriority`, and the calculation `count(*)` will be applied to the rows having a specific `orderpriority` value.\n\nThe calculations allowed are typically SUM/MIN/MAX/AVG/COUNT. However, some databases have more complex aggregate functions; check your DB documentation.\n\n### Use HAVING to filter based on the aggregates created by GROUP BY \n\n## Replicate IF.ELSE logic with CASE statements\n\nWe can do conditional logic in the `SELECT ... FROM` part of our query, as shown below.\n\n::: {#deb9aceb .cell execution_count=37}\n``` {.python .cell-code}\n%%sql\nSELECT\n    o_orderkey,\n    o_totalprice,\n    CASE\n        WHEN o_totalprice > 100000 THEN 'high'\n        WHEN o_totalprice BETWEEN 25000\n        AND 100000 THEN 'medium'\n        ELSE 'low'\n    END AS order_price_bucket\nFROM\n    orders;\n```\n:::\n\n\nWe can see how we display different values depending on the `totalprice` column. We can also use multiple criteria as our conditional criteria (e.g., totalprice > 100000 AND orderpriority = '2-HIGH').\n\n## Stack tables on top of each other with UNION and UNION ALL, subtract tables with EXCEPT\n\nWhen we want to combine data from tables by stacking them on top of each other, we use the UNION or UNION ALL operator. `UNION` removes duplicate rows, and `UNION ALL` does not remove duplicate rows. Let's look at an example.\n\n::: {#46cf5b6e .cell execution_count=38}\n``` {.python .cell-code}\n%%sql\n\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%' -- 25 rows\n```\n:::\n\n\n::: {#c460d8ec .cell execution_count=39}\n``` {.python .cell-code}\n%%sql\n-- UNION will remove duplicate rows; the below query will produce 25 rows\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE'%_91%'\nUNION\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%'\nUNION\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91'\n```\n:::\n\n\n::: {#ec138e39 .cell execution_count=40}\n``` {.python .cell-code}\n%%sql\n-- UNION ALL will not remove duplicate rows; the below query will produce 75 rows\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%'\nUNION ALL\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%'\nUNION ALL\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%';\n```\n:::\n\n\nWhen we want to retrieve all rows from the first dataset that are not present in the second dataset, we can use `EXCEPT`.\n\n::: {#e963e9d5 .cell execution_count=41}\n``` {.python .cell-code}\n%%sql\n-- EXCEPT will get the rows in the first query result that is not in the second query result, 0 rows\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%'\nEXCEPT\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%';\n```\n:::\n\n\n::: {#32bc07ec .cell execution_count=42}\n``` {.python .cell-code}\n%%sql\n-- The below query will result in 23 rows; the first query has 25 rows, and the second has two rows\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE'%_91%'\nEXCEPT\nSELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%191%';\n```\n:::\n\n\n## Sub-query: Use a query instead of a table\n\nWhen we want to use the result of a query as a table in another query, we use subqueries. Let's consider an example:\n\n1. Create a report that shows the nation, how many items it supplied (by suppliers in that nation), and how many items it purchased (by customers in that nation). \n\n::: {#7682e9d8 .cell execution_count=43}\n``` {.python .cell-code}\n%%sql\nSELECT\n  n.n_name AS nation_c_name,\n  s.quantity AS supplied_items_quantity,\n  c.quantity AS purchased_items_quantity\nFROM\n  nation n\n  LEFT JOIN (\n    SELECT\n      n.n_nationkey,\n      SUM(l.l_quantity) AS quantity\n    FROM\n      lineitem l\n      JOIN supplier s ON l.l_suppkey = s.s_suppkey\n      JOIN nation n ON s.s_nationkey = n.n_nationkey\n    GROUP BY\n      n.n_nationkey\n  ) s ON n.n_nationkey = s.n_nationkey\n  LEFT JOIN (\n    SELECT\n      n.n_nationkey,\n      SUM(l.l_quantity) AS quantity\n    FROM\n      lineitem l\n      JOIN orders o ON l.l_orderkey = o.o_orderkey\n      JOIN customer c ON o.o_custkey = c.c_custkey\n      JOIN nation n ON c.c_nationkey = n.n_nationkey\n    GROUP BY\n      n.n_nationkey\n  ) c ON n.n_nationkey = c.n_nationkey;\n```\n:::\n\n\nIn the above query, we can see that there are two sub-queries, one to calculate the quantity supplied by a nation and the other to calculate the quantity purchased by the customers of a nation.\n\n## Change data types (CAST) and handle NULLS (COALESCE)\n\nEvery column in a table has a specific data type. The data types fall under one of the following categories.\n\n1. **`Numerical`**: Data types used to store numbers.\n   1. Integer: Positive and negative numbers. Different types of Integer, such as tinyint, int, and bigint, allow storage of different ranges of values. Integers cannot have decimal digits.\n   2. Floating: These can have decimal digits but store an approximate value.\n   3. Decimal: These can have decimal digits and store the exact value. The decimal type allows you to specify the scale and precision. Where scale denotes the count of numbers allowed as a whole & precision denotes the count of numbers allowed after the decimal point. E.g., DECIMAL(8,3) allows eight numbers in total, with three allowed after the decimal point.\n2. **`Boolean`**: Data types used to store True or False values.\n3. **` String`**: Data types used to store alphanumeric characters.\n   1. Varchar(n): Data type allows storage of a variable character string, with a permitted max length n.\n   2. Char(n): Data type allows storage of a fixed character string. A column of char(n) type adds (length(string) - n) empty spaces to a string that does not have n characters.\n4. **`Date & time`**: Data types used to store dates, time, & timestamps(date + time).\n5. **` Objects (STRUCT, ARRAY, MAP, JSON)`**: Data types used to store JSON and ARRAY data.\n\nSome databases have data types that are unique to them as well. We should check the database documents to understand the data types offered.\n\nIt is best practice to use the appropriate data type for your columns. We can convert data types using the `CAST` function, as shown below.\n\nA `NULL` will be used for that field when a value is not present. In cases where we want to use the first non-NULL value from a list of columns, we use `COALESCE` as shown below.\n\nLet's consider the following example. We can see how when `l.orderkey` is NULL, the DB uses `999999` as the output.\n\n::: {#c9351037 .cell execution_count=44}\n``` {.python .cell-code}\n%%sql\nSELECT\n    o.o_orderkey,\n    o.o_orderdate,\n    COALESCE(l.l_orderkey, 9999999) AS lineitem_orderkey,\n    l.l_shipdate\nFROM\n    orders o\n    LEFT JOIN lineitem l ON o.o_orderkey = l.l_orderkey\n    AND o.o_orderdate BETWEEN l.l_shipdate - INTERVAL '5' DAY\n    AND l.l_shipdate + INTERVAL '5' DAY\nLIMIT\n    10;\n```\n:::\n\n\n## Use these standard inbuilt DB functions for String, Time, and Numeric data manipulation\nWhen processing data, more often than not, we will need to change values in columns; shown below are a few standard functions to be aware of:\n\n1. **` String functions`**\n   1. **LENGTH** is used to calculate the length of a string. E.g., `SELECT LENGTH('hi');` will output 2.\n   2. **CONCAT** combines multiple string columns into one. E.g., `SELECT CONCAT(clerk, '-', orderpriority) FROM ORDERS LIMIT 5;` will concatenate clerk and orderpriority columns with a dash in between them.\n   3. **SPLIT** is used to split a value into an array based on a given delimiter. E.g., `SELECT SPLIT(clerk, '#') FROM ORDERS LIMIT 5;` will output a column with arrays formed by splitting clerk values on `#`.\n   4. **SUBSTRING** is used to get a sub-string from a value, given the start and length. E.g., `SELECT clerk, SUBSTRING(clerk, 1, 5) FROM orders LIMIT 5;` will get the first five characters of the clerk column. Note that indexing starts from 1 in Spark SQL.\n   5. **TRIM** is used to remove empty spaces to the left and right of the value. E.g., `SELECT TRIM(' hi ');` will output `hi` without any spaces around it. LTRIM and RTRIM are similar but only remove spaces before and after the string, respectively.\n\n2. **` Date and Time functions`**\n   1. **Adding and subtracting dates**: Is used to add and subtract periods; the format heavily depends on the DB. E.g., In Spark SQL, the query\n      ```sql\n        SELECT\n        DATEDIFF(DATE '2023-11-05', DATE '2022-10-01') AS diff_in_days,\n        MONTHS_BETWEEN(DATE '2023-11-05', DATE '2022-10-01') AS diff_in_months,\n        YEAR(DATE '2023-11-05') - YEAR(DATE '2022-10-01') AS diff_in_years;\n      ```\n    It will show the difference between the two dates in the specified period. We can also add/subtract an arbitrary period from a date/time column. E.g., `SELECT DATE_ADD(DATE '2022-11-05', 10);` will show the output `2022-11-15`.\n\n   2. **string <=> date/time conversions**: When we want to change the data type of a string to date/time, we can use the `DATE 'YYYY-MM-DD'` or `TIMESTAMP 'YYYY-MM-DD HH:mm:SS'` functions. But when the data is in a different date/time format such as `MM/DD/YYYY`, we will need to specify the input structure; we do this using `TO_DATE` or `TO_TIMESTAMP`. E.g. `SELECT TO_DATE('11-05-2023', 'MM-dd-yyyy');`. We can convert a timestamp/date into a string with the required format using `DATE_FORMAT`. E.g., `SELECT DATE_FORMAT(orderdate, 'yyyy-MM-01') AS first_month_date FROM orders LIMIT 5;` will map every orderdate to the first of their month.\n   \n   3. **Time frame functions (YEAR/MONTH/DAY)**:  When we want to extract specific periods from a date/time column, we can use these functions. E.g., `SELECT YEAR(DATE '2023-11-05');` will return 2023. Similarly, we have MONTH, DAY, HOUR, MINUTE, etc.\n\n3. **`Numeric`**\n   1. **ROUND** is used to specify the number of digits allowed after the decimal point. E.g. `SELECT ROUND(100.102345, 2);`\n\n## Save queries as views for more straightforward reads\n\nWhen we have large/complex queries that we need to run often, we can save them as views. Views are database objects that operate similarly to tables. The OLAP DB executes the underlying query when we query a view. \n\nUse views to hide query complexities and limit column access (by exposing only specific table columns) for end-users.\n\nFor example, we can create a view for the nation-level report from the above section, as shown below.\n\n::: {#c9394fbc .cell execution_count=45}\n``` {.python .cell-code}\n%%sql\nDROP VIEW IF EXISTS nation_supplied_purchased_quantity\n```\n:::\n\n\n::: {#b99ee099 .cell execution_count=46}\n``` {.python .cell-code}\n%%sql\nCREATE VIEW nation_supplied_purchased_quantity AS\nSELECT\n    n.n_name AS nation_name,\n    s.quantity AS supplied_items_quantity,\n    c.quantity AS purchased_items_quantity\nFROM\n    nation n\n    LEFT JOIN (\n        SELECT\n            n_nationkey as nationkey,\n            sum(l_quantity) AS quantity\n        FROM\n            lineitem l\n            JOIN supplier s ON l.l_suppkey = s.s_suppkey\n            JOIN nation n ON s.s_nationkey = n.n_nationkey\n        GROUP BY\n            n.n_nationkey\n    ) s ON n.n_nationkey = s.nationkey\n    LEFT JOIN (\n        SELECT\n            n_nationkey as nationkey,\n            sum(l_quantity) AS quantity\n        FROM\n            lineitem l\n            JOIN orders o ON l.l_orderkey = o.o_orderkey\n            JOIN customer c ON o.o_custkey = c.c_custkey\n            JOIN nation n ON c.c_nationkey = n.n_nationkey\n        GROUP BY\n            n.n_nationkey\n    ) c ON n.n_nationkey = c.nationkey;\n```\n:::\n\n\n::: {#1e09f944 .cell execution_count=47}\n``` {.python .cell-code}\n%%sql\nSELECT\n    *\nFROM\n    nation_supplied_purchased_quantity;\n```\n:::\n\n\nNow the view `nation_supplied_purchased_quantity` will run the underlying query when used.\n\n\n## Exercises\n\n1. Create a report that shows the number of returns for each region name\n**Topics**: JOINs, GROUP BY, COUNT\n2. Top 10 most selling parts\n**Topics**: aggregations, ranking, LIMIT, top N analysis\n3. Sellers who sell at least one of the top 10 selling parts\n**Topics**: subqueries\n4. Number of returns per order price bucket\n**Topics**: CASE statements, data bucketing, conditional logic\n```sql\nCASE\n    WHEN o_totalprice > 100000 THEN 'high'\n    WHEN o_totalprice BETWEEN 25000 AND 100000 THEN 'medium'\n    ELSE 'low'\nEND AS order_price_bucket\n```\n5. Average time (in days) between receiptdate and shipdate for each nation\n**Topics**: date arithmetic, time calculations\n\n\n## Recommended reading\n\n1. https://www.startdataengineering.com/post/improve-sql-skills-de/\n2. https://www.startdataengineering.com/post/n-sql-tips-de/\n3. https://www.startdataengineering.com/post/advanced-sql/\n\n",
    "supporting": [
      "sql_basics_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}