{
  "hash": "6920ceaa94b86d8853196650f83ada9b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Manipulate data with standard libraries and co-locate code with classes and functions\nformat:\n  html:\n    toc: true\nexecute:\n  eval: false\n  output: true\njupyter: python3\n---\n\n\n\n\nIn this chapter we will see how to use Python data structures and OOM and functions.\n\n### Use the appropriate data structure based on how data will be used\n\nLet's go over some basics of the Python language:\n\n1. **`Variables`**: A storage location identified by its name, containing some value.\n2. **`Operations`**: We can do any operation (arithmetic for numbers, string transformation for text) on variables\n3. **`Data Structures`**: They are ways of representing data. Each has its own pros and cons and places where it is the right fit.\n    3.1. **`List`**: A collection of elements that can be accessed by knowing the element's location (aka index). Lists retain the order of elements in them.\n  \n    3.2. **`Dictionary`**: A collection of key-value pairs where each key is mapped to a value using a hash function. The dictionary provides fast data retrieval based on keys.\n\n    3.3. **`Set`**: A collection of unique elements that do not allow duplicates.\n\n    3.4. **`Tuple`**: A collection of immutable(non changeable) elements, tuples retain their order once created.\n\n::: {#ea5bd601 .cell execution_count=1}\n``` {.python .cell-code}\na = 10\nb = 20\n\nc = a + b\nprint(c)\n\ns = '  Some string '\nprint(s.strip())\n\nl = [1, 2, 3, 4]\n\nprint(l[0])  # Will print 1\nprint(l[3])  # Will print 4\n\nd = {'a': 1, 'b': 2}\n\nprint(d.get('a'))\nprint(d.get('b'))\n\nmy_set = set()\nmy_set.add(10)\nmy_set.add(10)\nmy_set.add(10)\nmy_set.add(30)\nprint(my_set)\n```\n:::\n\n\n### Manipulate data with control-flow loops\n\n4. **`Loops`**: Looping allows a specific chunk of code to be repeated several times. The most common type is the `for` loop.\n\n    4.1. **`Comprehension`**: Comprehension is a shorthand way of writing a loop. This allows for concise code, great for representing simpler logic.\n\n::: {#57ec92f6 .cell execution_count=2}\n``` {.python .cell-code}\nfor i in range(11):\n    print(i)\n\nfor elt in l:\n    print(elt)\n\nfor k, v in d.items():\n    print(f'Key: {k}, Value: {v}')\n\n[elt*2 for elt in l]\n\ndef gt_three(input_list):\n    return [elt for elt in input_list if elt > 3]\n\nlist_1 = [1, 2, 3, 4, 5, 6]\nprint(gt_three(list_1))\n\nlist_2 = [1, 2, 3, 1, 1, 1]\nprint(gt_three(list_2))\n```\n:::\n\n\n### Co-locate logic with classes and functions\n\n5. **`Functions`**: A block of code that can be reused as needed. This allows us to have logic defined in one place, making it easy to maintain and use. Using it in a location is referred to as calling the function.\n6. **`Class and Objects`**: Think of a class as a blueprint and objects as things created based on that blueprint.\n7. **`Library`**: Libraries are code that can be reused. Python comes with standard libraries for common operations, such as a datetime library to work with time (although there are better libraries)â€”[Standard library](https://docs.python.org/3/library/index.html).\n8. **`Exception handling`**: When an error occurs, we need our code to gracefully handle it without stopping. \n\n::: {#c5a533e6 .cell execution_count=3}\n``` {.python .cell-code}\nclass DataExtractor:\n\n    def __init__(self, some_value):\n        self.some_value = some_value\n\n    def get_connection(self):\n        pass\n\n    def close_connection(self):\n        pass\n\nde_object = DataExtractor(10)\nprint(de_object.some_value)\n\nfrom datetime import datetime\nprint(datetime.now().strftime('%Y %m %d'))\n\nl = [1, 2, 3, 4, 5]\nindex = 10\ntry:\n    element = l[index]\n    print(f\"Element at index {index} is {element}\")\nexcept IndexError:\n    print(f\"Error: Index {index} is out of range for the list.\")\nfinally:\n    print(\"Execution completed.\")\n```\n:::\n\n\n",
    "supporting": [
      "py_basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}