{"title":"Use window function when you need to use values from other rows to compute a value for the current row","markdown":{"yaml":{"title":"Use window function when you need to use values from other rows to compute a value for the current row","format":{"html":{"toc":true}},"execute":{"eval":false,"output":true},"jupyter":"python3"},"headingText":"Window functions have four parts","containsRefs":false,"markdown":"\n\n\nWindow functions allow you to operate on a set of rows at a time and produce output which has the same grain as the input (vs GROUP BY which operates on a set of rows, but also changes the meaning of an output row).\n\n\nLets see why we may need window functions as opposed to a `GROUP BY`.\n\n![GROUP BY](../../images/groupby.png)\n\n![WINDOW FUNCTION](../../images/window.png)\n\n**NOTE** Notice how `GROUP BY` changes granularity, i.e. the input data had one row per order (aka order grain or order level) but the output had one row per date (aka date grain or date level).\n\nWhen you perform some operation that requires data from multiple rows to produce the data for one row without changing the grain `Window functions` are almost always a good fit.\n\n**Common scenarios when you want to use window functions**:\n\n1. Calculate running metrics/sliding window over rows in the table (aggregate functions)\n2. Ranking rows based on values in column(s) (ranking functions)\n3. Access other row's values while operating on the current row (value functions)\n4. Any combination of the above\n\n\n1. **Partition**: Defines a set of rows based on specified column(s) value. If no partition is specified, the entire table is considered a partition.\n2. **Order By**: This optional clause specifies how to order the rows within a partition. This is an optional clause, without this the rows inside a partition will not be ordered.\n3. **Function**: The function to be applied on the current row. \n4. **Window frame**: Within a partition, a window frame allows you to specify the rows to be considered in the function computation. This enables more options on how one can choose the rows to apply the function on.\n\n![](../../images/framing.svg)\n\n![Create window function](../../images/create_window.png)\n\n```{python}\n%%sql\nuse prod.db\n```\n\n```{python}\n%%sql\nSELECT\n  o_custkey,\n  o_orderdate,\n  o_totalprice,\n  SUM(o_totalprice) -- FUNCTION \n  OVER (\n    PARTITION BY\n      o_custkey -- PARTITION\n    ORDER BY\n      o_orderdate -- ORDER BY; ASCENDING ORDER unless specified as DESC\n  ) AS running_sum\nFROM\n  orders\nWHERE\n  o_custkey = 4\nORDER BY\n  o_orderdate\nLIMIT\n  10;\n```\n\nThe function `SUM` that we use in the above query is an aggregate function. Notice how the `running_sum` adds up (aka aggregates) the `o_totalprice` over all the rows. The rows themselves are ordered in ascending order by its orderdate.\n\n**Reference**: The standard aggregate functions are `MIN, MAX, AVG, SUM, & COUNT`, modern data systems offer a variety of powerful aggregations functions. Check your database documentation for available aggreagate functions. [e.g. list of agg functions available in TrinoDB](https://trino.io/docs/current/functions/window.html#functions-window--page-root)\n\nWrite a query to calculate the daily running average of totalprice of every customer. \n\n**Hint**: Figure out the `PARTITION BY` column first, then the `ORDER BY` column and finally the `FUNCTION` to use to compute running average.\n\n### Use window frames to define a set of rows to operate on\n\nWindow functions consider all the rows in a partition (depending on the type of function add:link) by default. However using a window frame one can select a set of rows withing a partition to operate on.\n\n![Three order Sliding window average](../../images/slidingwindow.png)\n\n\nExample\n\nConsider a scenario where you have sales data, and you want to calculate a 3-day moving average of sales within each store:\n\n\ny%%sql\nSELECT\n    store_id,\n    sale_date,\n    sales_amount,\n    AVG(sales_amount) OVER (\n        PARTITION BY store_id\n        ORDER BY sale_date\n        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n    ) AS moving_avg_sales\nFROM\n    sales;\n\nIn this example:\n\n1. **PARTITION BY** store_id ensures the calculation is done separately for each store.\n2. **ORDER BY** sale_date defines the order of rows within each partition.\n3. **ROWS BETWEEN 2 PRECEDING AND CURRENT ROW** specifies the window frame, considering the current row and the two preceding rows to calculate the moving average.\nadd: image\nWithout defining the window frame, the function might not be able to provide the specific moving average calculation you need.\n\n#### Use ordering of rows to define your window frame with the ROWS clause \n\n1. **ROWS**: Used to select a set of rows relative to the current row based on position.\n    1. Row definition format `ROWS BETWEEN start_point AND end_point`.\n    2. The start_point and end_point can be any of the following three (in the proper order:\n        1. **n PRECEDING**: n rows preceding the current row. UNBOUNDED PRECEDING indicates all rows before the current row.\n        2. **n FOLLOWING**: n rows following the current row. UNBOUNDED FOLLOWING indicates all rows after the current row.\n\n\nLet's see how relative row numbers can be used to define a window range.\n\nConsider this window function \n\n```sql\nAVG(total_price) OVER ( -- FUNCTION: RUNNING AVERAGE\n    PARTITION BY o_custkey -- PARTITIONED BY customer\n    ORDER BY order_month \n    ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING -- WINDOW FRAME DEFINED AS 1 ROW PRECEDING to 1 ROW FOLLOWING\n    )\n```\n\n![Window frame with ROWS](../../images/wf.png)\n\n\n\n#### Use values of the columns to define window frame using RANGE clause\n\n1. **RANGE**: Used to select a set of rows relative to the current row based on the value of the columns specified in the `ORDER BY` clause.\n    1. Range definition format `RANGE BETWEEN start_point AND end_point`.\n    2. The start_point and end_point can be any of the following:\n        1. **CURRENT ROW**: The current row.\n        2. **n PRECEDING**: All rows with values within the specified range that are less than or equal to n units preceding the value of the current row.\n        3. **n FOLLOWING**: All rows with values within the specified range that are greater than or equal to n units following the value of the current row.\n        4. **UNBOUNDED PRECEDING**: All rows before the current row within the partition.\n        5. **UNBOUNDED FOLLOWING**: All rows after the current row within the partition.\n    3. `RANGE` is particularly useful when dealing with numeric or date/time ranges, allowing for calculations like running totals, moving averages, or cumulative distributions.\n\nLet's see how `RANGE` works with `AVG(total price) OVER (PARTITION BY customer id ORDER BY date RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND '1' DAY FOLLOWING)` using the below visualization:\n\n![RANGE](../../images/range.png)\n\n## Ranking functions enable you to rank your rows based on order by clause\n\nIf you are working on a problem to get the top/bottom n rows (as defined by some value) then use the **row** functions.\n\nLet's look at an example of how to use a row function:\n\nFrom the `orders` table **get the top 3 spending customers per day**. The orders table schema is shown below:\n\n![Orders table](../../images/orders.png)\n\n```{python}\n%%sql\nSELECT\n  *\nFROM\n  (\n    SELECT\n      o_orderdate,\n      o_totalprice,\n      o_custkey,\n      RANK() -- RANKING FUNCTION \n      OVER (\n        PARTITION BY\n          o_orderdate -- PARTITION BY order date\n        ORDER BY\n          o_totalprice DESC -- ORDER rows withing partition by totalprice\n      ) AS rnk\n    FROM\n      orders\n  )\nWHERE\n  rnk <= 3\nORDER BY\n  o_orderdate\nLIMIT\n  5;\n```\n\n\nStandard RANKING functions: \n\n1. **`RANK`**: Ranks the rows starting from 1 to n within the window frame. Ranks the rows with the same value (defined by the \"ORDER BY\" clause) as the same and skips the ranking numbers that would have been present if the values were different.\n\n2. **`DENSE_RANK`**: Ranks the rows starting from 1 to n within the window frame. Ranks the rows with the same value (defined by the \"ORDER BY\" clause) as the same and does not skip any ranking numbers.\n\n3. **`ROW_NUMBER`**: Adds a row number that starts from 1 to n within the window frame and does not create any repeating values.\n\n\n```{python}\n%%sql\n-- Let's look at an example showing the difference between RANK, DENSE_RANK and ROW_NUMBER\nSELECT \n    order_date,\n    order_id,\n    total_price,\n    ROW_NUMBER() OVER (PARTITION BY order_date ORDER BY total_price) AS row_number,\n    RANK() OVER (PARTITION BY order_date ORDER BY total_price) AS rank,\n    DENSE_RANK() OVER (PARTITION BY order_date ORDER BY total_price) AS dense_rank\nFROM (\n    SELECT \n        '2024-07-08' AS order_date, 'order_1' AS order_id, 100 AS total_price UNION ALL\n    SELECT \n        '2024-07-08', 'order_2', 200 UNION ALL\n    SELECT \n        '2024-07-08', 'order_3', 150 UNION ALL\n    SELECT \n        '2024-07-08', 'order_4', 90 UNION ALL\n    SELECT \n        '2024-07-08', 'order_5', 100 UNION ALL\n    SELECT \n        '2024-07-08', 'order_6', 90 UNION ALL\n    SELECT \n        '2024-07-08', 'order_7', 100 UNION ALL\n    SELECT \n        '2024-07-10', 'order_8', 100 UNION ALL\n    SELECT \n        '2024-07-10', 'order_9', 100 UNION ALL\n    SELECT \n        '2024-07-10', 'order_10', 100 UNION ALL\n    SELECT \n        '2024-07-11', 'order_11', 100\n) AS orders\nORDER BY order_date, row_number;\n```\n\nNow that we have see how to **define a window function** and how to use **ranking and aggregation** functions, let's take it a step further by practicing **value functions**.\n\nRemember that value functions are used to access other row's values while operating on the current row\n\nLet's take a look at LEAD and LAG functions:\n\n![LAG AND LEAD](../../images/leadlag.png)\n\n## Value functions are used to access other rows values\n\n\nStandard VALUE functions: \n\n1. **NTILE(n)**: Divides the rows in the window frame into n approximately equal groups, and assigns a number to each row indicating which group it belongs to.\n2. **FIRST_VALUE()**: Returns the first value in the window frame.\n3. **LAST_VALUE()**: Returns the last value in the window frame.\n4. **LAG()**: Accesses data from a previous row within the window frame.\n5. **LEAD()**: Accesses data from a subsequent row within the window frame.\n\n## Aggregate functions enable you to compute running metrics \n\nThe standard aggregate functions are `MIN, MAX, AVG, SUM, & COUNT`. In addition to these make sure to check your DB engine documentation, in our case Spark Aggregate functions.\n\nWhen you need a running sum/min/max/avg, its almost always a use case for aggregate functions with windows.\n\n## Exercises\n\n1. Write a query on the orders table that has the following output:\n    1. o_custkey\n    2. order_month: In YYYY-MM format, use strftime(o_orderdate, '%Y-%m') AS order_month\n    3. total_price: Sum of o_totalprice for that month\n    4. three_mo_total_price_avg: The 3 month (previous, current & next) average of total_price for that customer\n\n```{python}\n%%sql\nSELECT\n  order_month,\n  o_custkey,\n  total_price,\n  ROUND(\n    AVG(total_price) OVER ( -- FUNCTION: RUNNING AVERAGE\n      PARTITION BY\n        o_custkey -- PARTITIONED BY customer\n      ORDER BY\n        order_month ROWS BETWEEN 1 PRECEDING\n        AND 1 FOLLOWING -- WINDOW FRAME DEFINED AS 1 ROW PRECEDING to 1 ROW FOLLOWING\n    ),\n    2\n  ) AS three_mo_total_price_avg\nFROM\n  (\n    SELECT\n      date_format(o_orderdate, 'yyyy-MM') AS order_month,\n      o_custkey,\n      SUM(o_totalprice) AS total_price\n    FROM\n      orders\n    GROUP BY\n      1,\n      2\n  )\nLIMIT\n  5;\n```\n\nNow that we have seen how to create a window frame with ROWS, let' explore how to do this with RANGE.\n\n2. Write a query on the orders table that has the following output:\n    1. order_month, \n    2. o_custkey,\n    3. total_price,\n    4. three_mo_total_price_avg\n    5. **consecutive_three_mo_total_price_avg**: The consecutive 3 month average of total_price for that customer. Note that this should only include months that are chronologically next to each other.\n                                                                                               \n**Time limit during live workshop: 10 min**\n                                                                                               \n**Hint**: Use `CAST(strftime(o_orderdate, '%Y-%m-01') AS DATE)` to cast order_month to date format.\n\n**Hint**: Use the `INTERVAL` format shown above to construct the window function to compute `consecutive_three_mo_total_price_avg` column.\n                                                                                           \n* The orders table schema is shown below:\n\n![Orders table](../../images/orders.png)\n\n```sql\n-- write your query here\n```\n\n3. From the `orders` table get the 3 lowest spending customers per day \n\n**Time limit during live workshop: 5 min**\n\n**Hint**\n  1. Figure out the `PARTITION BY` column first, then the `ORDER BY` column and finally the `FUNCTION` to use to compute running average.\n\nThe orders table schema is shown below:\n\n![Orders table](../../images/orders.png)\n\n\n```sql \n-- your code here\n```\n\n4. Write a SQL query using the `orders` table that calculates the following columns:\n\t1. o_orderdate: From orders table\n\t2. o_custkey: From orders table\n\t3. o_totalprice: From orders table\n\t4. totalprice_diff: The customers current day's o_totalprice - that same customers most recent previous purchase's o_totalprice\n\n* **Time limit during live workshop: 5 min**\n\n* **Hint**: \n    1. Start by figuring out what the `PARTITION BY` column should be, then what the `ORDER BY` column should be, and then finally the function to use. \n    2. Use the `LAG(column_name)` ranking function to identify the prior day's revenue.\n\n* The orders table schema is shown below:\n\n![Orders table](../../images/orders.png)\n\n\n```sql\n-- write your query here\n```\n\n## Recommended reading\n\n1. Window SQL Youtube workshop\n\n","srcMarkdownNoYaml":"\n\n\nWindow functions allow you to operate on a set of rows at a time and produce output which has the same grain as the input (vs GROUP BY which operates on a set of rows, but also changes the meaning of an output row).\n\n\nLets see why we may need window functions as opposed to a `GROUP BY`.\n\n![GROUP BY](../../images/groupby.png)\n\n![WINDOW FUNCTION](../../images/window.png)\n\n**NOTE** Notice how `GROUP BY` changes granularity, i.e. the input data had one row per order (aka order grain or order level) but the output had one row per date (aka date grain or date level).\n\nWhen you perform some operation that requires data from multiple rows to produce the data for one row without changing the grain `Window functions` are almost always a good fit.\n\n**Common scenarios when you want to use window functions**:\n\n1. Calculate running metrics/sliding window over rows in the table (aggregate functions)\n2. Ranking rows based on values in column(s) (ranking functions)\n3. Access other row's values while operating on the current row (value functions)\n4. Any combination of the above\n\n## Window functions have four parts\n\n1. **Partition**: Defines a set of rows based on specified column(s) value. If no partition is specified, the entire table is considered a partition.\n2. **Order By**: This optional clause specifies how to order the rows within a partition. This is an optional clause, without this the rows inside a partition will not be ordered.\n3. **Function**: The function to be applied on the current row. \n4. **Window frame**: Within a partition, a window frame allows you to specify the rows to be considered in the function computation. This enables more options on how one can choose the rows to apply the function on.\n\n![](../../images/framing.svg)\n\n![Create window function](../../images/create_window.png)\n\n```{python}\n%%sql\nuse prod.db\n```\n\n```{python}\n%%sql\nSELECT\n  o_custkey,\n  o_orderdate,\n  o_totalprice,\n  SUM(o_totalprice) -- FUNCTION \n  OVER (\n    PARTITION BY\n      o_custkey -- PARTITION\n    ORDER BY\n      o_orderdate -- ORDER BY; ASCENDING ORDER unless specified as DESC\n  ) AS running_sum\nFROM\n  orders\nWHERE\n  o_custkey = 4\nORDER BY\n  o_orderdate\nLIMIT\n  10;\n```\n\nThe function `SUM` that we use in the above query is an aggregate function. Notice how the `running_sum` adds up (aka aggregates) the `o_totalprice` over all the rows. The rows themselves are ordered in ascending order by its orderdate.\n\n**Reference**: The standard aggregate functions are `MIN, MAX, AVG, SUM, & COUNT`, modern data systems offer a variety of powerful aggregations functions. Check your database documentation for available aggreagate functions. [e.g. list of agg functions available in TrinoDB](https://trino.io/docs/current/functions/window.html#functions-window--page-root)\n\nWrite a query to calculate the daily running average of totalprice of every customer. \n\n**Hint**: Figure out the `PARTITION BY` column first, then the `ORDER BY` column and finally the `FUNCTION` to use to compute running average.\n\n### Use window frames to define a set of rows to operate on\n\nWindow functions consider all the rows in a partition (depending on the type of function add:link) by default. However using a window frame one can select a set of rows withing a partition to operate on.\n\n![Three order Sliding window average](../../images/slidingwindow.png)\n\n\nExample\n\nConsider a scenario where you have sales data, and you want to calculate a 3-day moving average of sales within each store:\n\n\ny%%sql\nSELECT\n    store_id,\n    sale_date,\n    sales_amount,\n    AVG(sales_amount) OVER (\n        PARTITION BY store_id\n        ORDER BY sale_date\n        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n    ) AS moving_avg_sales\nFROM\n    sales;\n\nIn this example:\n\n1. **PARTITION BY** store_id ensures the calculation is done separately for each store.\n2. **ORDER BY** sale_date defines the order of rows within each partition.\n3. **ROWS BETWEEN 2 PRECEDING AND CURRENT ROW** specifies the window frame, considering the current row and the two preceding rows to calculate the moving average.\nadd: image\nWithout defining the window frame, the function might not be able to provide the specific moving average calculation you need.\n\n#### Use ordering of rows to define your window frame with the ROWS clause \n\n1. **ROWS**: Used to select a set of rows relative to the current row based on position.\n    1. Row definition format `ROWS BETWEEN start_point AND end_point`.\n    2. The start_point and end_point can be any of the following three (in the proper order:\n        1. **n PRECEDING**: n rows preceding the current row. UNBOUNDED PRECEDING indicates all rows before the current row.\n        2. **n FOLLOWING**: n rows following the current row. UNBOUNDED FOLLOWING indicates all rows after the current row.\n\n\nLet's see how relative row numbers can be used to define a window range.\n\nConsider this window function \n\n```sql\nAVG(total_price) OVER ( -- FUNCTION: RUNNING AVERAGE\n    PARTITION BY o_custkey -- PARTITIONED BY customer\n    ORDER BY order_month \n    ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING -- WINDOW FRAME DEFINED AS 1 ROW PRECEDING to 1 ROW FOLLOWING\n    )\n```\n\n![Window frame with ROWS](../../images/wf.png)\n\n\n\n#### Use values of the columns to define window frame using RANGE clause\n\n1. **RANGE**: Used to select a set of rows relative to the current row based on the value of the columns specified in the `ORDER BY` clause.\n    1. Range definition format `RANGE BETWEEN start_point AND end_point`.\n    2. The start_point and end_point can be any of the following:\n        1. **CURRENT ROW**: The current row.\n        2. **n PRECEDING**: All rows with values within the specified range that are less than or equal to n units preceding the value of the current row.\n        3. **n FOLLOWING**: All rows with values within the specified range that are greater than or equal to n units following the value of the current row.\n        4. **UNBOUNDED PRECEDING**: All rows before the current row within the partition.\n        5. **UNBOUNDED FOLLOWING**: All rows after the current row within the partition.\n    3. `RANGE` is particularly useful when dealing with numeric or date/time ranges, allowing for calculations like running totals, moving averages, or cumulative distributions.\n\nLet's see how `RANGE` works with `AVG(total price) OVER (PARTITION BY customer id ORDER BY date RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND '1' DAY FOLLOWING)` using the below visualization:\n\n![RANGE](../../images/range.png)\n\n## Ranking functions enable you to rank your rows based on order by clause\n\nIf you are working on a problem to get the top/bottom n rows (as defined by some value) then use the **row** functions.\n\nLet's look at an example of how to use a row function:\n\nFrom the `orders` table **get the top 3 spending customers per day**. The orders table schema is shown below:\n\n![Orders table](../../images/orders.png)\n\n```{python}\n%%sql\nSELECT\n  *\nFROM\n  (\n    SELECT\n      o_orderdate,\n      o_totalprice,\n      o_custkey,\n      RANK() -- RANKING FUNCTION \n      OVER (\n        PARTITION BY\n          o_orderdate -- PARTITION BY order date\n        ORDER BY\n          o_totalprice DESC -- ORDER rows withing partition by totalprice\n      ) AS rnk\n    FROM\n      orders\n  )\nWHERE\n  rnk <= 3\nORDER BY\n  o_orderdate\nLIMIT\n  5;\n```\n\n\nStandard RANKING functions: \n\n1. **`RANK`**: Ranks the rows starting from 1 to n within the window frame. Ranks the rows with the same value (defined by the \"ORDER BY\" clause) as the same and skips the ranking numbers that would have been present if the values were different.\n\n2. **`DENSE_RANK`**: Ranks the rows starting from 1 to n within the window frame. Ranks the rows with the same value (defined by the \"ORDER BY\" clause) as the same and does not skip any ranking numbers.\n\n3. **`ROW_NUMBER`**: Adds a row number that starts from 1 to n within the window frame and does not create any repeating values.\n\n\n```{python}\n%%sql\n-- Let's look at an example showing the difference between RANK, DENSE_RANK and ROW_NUMBER\nSELECT \n    order_date,\n    order_id,\n    total_price,\n    ROW_NUMBER() OVER (PARTITION BY order_date ORDER BY total_price) AS row_number,\n    RANK() OVER (PARTITION BY order_date ORDER BY total_price) AS rank,\n    DENSE_RANK() OVER (PARTITION BY order_date ORDER BY total_price) AS dense_rank\nFROM (\n    SELECT \n        '2024-07-08' AS order_date, 'order_1' AS order_id, 100 AS total_price UNION ALL\n    SELECT \n        '2024-07-08', 'order_2', 200 UNION ALL\n    SELECT \n        '2024-07-08', 'order_3', 150 UNION ALL\n    SELECT \n        '2024-07-08', 'order_4', 90 UNION ALL\n    SELECT \n        '2024-07-08', 'order_5', 100 UNION ALL\n    SELECT \n        '2024-07-08', 'order_6', 90 UNION ALL\n    SELECT \n        '2024-07-08', 'order_7', 100 UNION ALL\n    SELECT \n        '2024-07-10', 'order_8', 100 UNION ALL\n    SELECT \n        '2024-07-10', 'order_9', 100 UNION ALL\n    SELECT \n        '2024-07-10', 'order_10', 100 UNION ALL\n    SELECT \n        '2024-07-11', 'order_11', 100\n) AS orders\nORDER BY order_date, row_number;\n```\n\nNow that we have see how to **define a window function** and how to use **ranking and aggregation** functions, let's take it a step further by practicing **value functions**.\n\nRemember that value functions are used to access other row's values while operating on the current row\n\nLet's take a look at LEAD and LAG functions:\n\n![LAG AND LEAD](../../images/leadlag.png)\n\n## Value functions are used to access other rows values\n\n\nStandard VALUE functions: \n\n1. **NTILE(n)**: Divides the rows in the window frame into n approximately equal groups, and assigns a number to each row indicating which group it belongs to.\n2. **FIRST_VALUE()**: Returns the first value in the window frame.\n3. **LAST_VALUE()**: Returns the last value in the window frame.\n4. **LAG()**: Accesses data from a previous row within the window frame.\n5. **LEAD()**: Accesses data from a subsequent row within the window frame.\n\n## Aggregate functions enable you to compute running metrics \n\nThe standard aggregate functions are `MIN, MAX, AVG, SUM, & COUNT`. In addition to these make sure to check your DB engine documentation, in our case Spark Aggregate functions.\n\nWhen you need a running sum/min/max/avg, its almost always a use case for aggregate functions with windows.\n\n## Exercises\n\n1. Write a query on the orders table that has the following output:\n    1. o_custkey\n    2. order_month: In YYYY-MM format, use strftime(o_orderdate, '%Y-%m') AS order_month\n    3. total_price: Sum of o_totalprice for that month\n    4. three_mo_total_price_avg: The 3 month (previous, current & next) average of total_price for that customer\n\n```{python}\n%%sql\nSELECT\n  order_month,\n  o_custkey,\n  total_price,\n  ROUND(\n    AVG(total_price) OVER ( -- FUNCTION: RUNNING AVERAGE\n      PARTITION BY\n        o_custkey -- PARTITIONED BY customer\n      ORDER BY\n        order_month ROWS BETWEEN 1 PRECEDING\n        AND 1 FOLLOWING -- WINDOW FRAME DEFINED AS 1 ROW PRECEDING to 1 ROW FOLLOWING\n    ),\n    2\n  ) AS three_mo_total_price_avg\nFROM\n  (\n    SELECT\n      date_format(o_orderdate, 'yyyy-MM') AS order_month,\n      o_custkey,\n      SUM(o_totalprice) AS total_price\n    FROM\n      orders\n    GROUP BY\n      1,\n      2\n  )\nLIMIT\n  5;\n```\n\nNow that we have seen how to create a window frame with ROWS, let' explore how to do this with RANGE.\n\n2. Write a query on the orders table that has the following output:\n    1. order_month, \n    2. o_custkey,\n    3. total_price,\n    4. three_mo_total_price_avg\n    5. **consecutive_three_mo_total_price_avg**: The consecutive 3 month average of total_price for that customer. Note that this should only include months that are chronologically next to each other.\n                                                                                               \n**Time limit during live workshop: 10 min**\n                                                                                               \n**Hint**: Use `CAST(strftime(o_orderdate, '%Y-%m-01') AS DATE)` to cast order_month to date format.\n\n**Hint**: Use the `INTERVAL` format shown above to construct the window function to compute `consecutive_three_mo_total_price_avg` column.\n                                                                                           \n* The orders table schema is shown below:\n\n![Orders table](../../images/orders.png)\n\n```sql\n-- write your query here\n```\n\n3. From the `orders` table get the 3 lowest spending customers per day \n\n**Time limit during live workshop: 5 min**\n\n**Hint**\n  1. Figure out the `PARTITION BY` column first, then the `ORDER BY` column and finally the `FUNCTION` to use to compute running average.\n\nThe orders table schema is shown below:\n\n![Orders table](../../images/orders.png)\n\n\n```sql \n-- your code here\n```\n\n4. Write a SQL query using the `orders` table that calculates the following columns:\n\t1. o_orderdate: From orders table\n\t2. o_custkey: From orders table\n\t3. o_totalprice: From orders table\n\t4. totalprice_diff: The customers current day's o_totalprice - that same customers most recent previous purchase's o_totalprice\n\n* **Time limit during live workshop: 5 min**\n\n* **Hint**: \n    1. Start by figuring out what the `PARTITION BY` column should be, then what the `ORDER BY` column should be, and then finally the function to use. \n    2. Use the `LAG(column_name)` ranking function to identify the prior day's revenue.\n\n* The orders table schema is shown below:\n\n![Orders table](../../images/orders.png)\n\n\n```sql\n-- write your query here\n```\n\n## Recommended reading\n\n1. Window SQL Youtube workshop\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc-depth":4,"toc":true,"output-file":"windows.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","bibliography":["references.bib"],"theme":"cosmo","title":"Use window function when you need to use values from other rows to compute a value for the current row","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"windows.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"documentclass":"scrreprt","title":"Use window function when you need to use values from other rows to compute a value for the current row","jupyter":"python3"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}